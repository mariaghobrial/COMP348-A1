; number of sub trees
; the root of subtree is > < 
; size of cdr should be < 3
; if () nill 0
; binary(car (cdr))
; binary (cdr(cdr))
; setq left right
; right=car(list)


; this will traverse the left-subtree of the list
(defun left-subtree(list)
 (cond 
     ((null list) nil)
     (t (car (cdr list)))
 )
)
; this will traverse the right-subtree of the list
(defun right-subtree(list)
 (cond 
     ((null list) nil)
     (t (car (cdr (cdr list))))
 )
    
)
(defun inorder(list)
    (cond 
     ( (null list) '() )
     ( (< (list-length list) 2) '(lstLength) )     
        ;(( > inorder (left-subtree list)  car list) '(NotaBST))
      ;  ((inorder (right-subtree list) < car list) )
     (t ( append  (inorder (left-subtree list)) (list (car list)) (inorder (right-subtree list)) ) )
      
           
    )
)

(defun binary-search (list)
   ; (setq size (- (list-length list) 1))
    (cond 
        ( (null list) '(TreeNull) )
        ( ( < (list-length list) 2) '(NotaBST_length))
        ( ( > (car (inorder (left-subtree list))) (car list)) '(left) )
        ( ( < (car (inorder (right-subtree list))) (car list)) '(right) )
        (t)
        ; ((atom list) (let left list))
       ; (t(helper list))
     ) 
)


;(print (binary-search '()))
;(print (binary-search '(3 4 5)))
(print (binary-search '(5 (3 ()()) (2 () ()) )))
(print (binary-search '(8 (3 (1 () ()) (6 (4 () ())(7 () ()))) (10 () (14 (13 () ()) ()))))   )
;(print (binary-search '(7 ( 1 () ( 2 () () ) )( 8 () ( 9 () () ) ) ) )        )    
